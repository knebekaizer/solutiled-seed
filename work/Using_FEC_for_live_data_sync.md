### RaptorQ для раздачи данных с DS  клиентам
Key words: Fountain codes, RaptorQ, multiplayer, dedicated server

Сценарий:  многопользовательская игра, авторитативный сервер раздает клиентам "состояние мира", вычисленное на каждом тике.

- Currect state - это просто blob, большая структура. Следовательно, задача - мультикаст блоба на несколько клиентов.
- В UE "состояние" - просто множество акторов, которые сервер пытается передать. Каждого актора UE отправляет независимо. Если часть пакетов не дойдет - "мир" будет "дырявым", неконсистентным. Система довольно толерантная к потерям, но неконсистентность может больно сказаться на клиенте.
- Обычно отправляется diff, но время от времени надо бродкастить key frame. Поэтому, без потери общности, говорим про передачу полного состояния. Это вляиет только на размер блоба.


#### Assumptions, limitations, caveats

- Критический показатель - задержка (latency), с которой клиент получает очередной апдейт. Трафик небольшой. Любой обратный канал (TCP ack, UDP retry) вносит задержку порядка RTT - неприемлемо. Надо использовать FEC (forward error correctoion) чтобы посылка доходила без ретраев и подтверждений. 
- Надо гибко регулировать избыточность для достижения достаточной вероятности получения. Характер потерь имеет значение, не только проценет потерь (window congestion, [acket drop, etc)
- Наивное решение (нерабочее). Сервер нарезает блоб на UDP пакеты и отправляет их клиентам. Использует простой FEC (типа XOR) или карусель. На каждом тике формирует новый блоб для отправки. Проблема: если у клиента плохие условия, он на каждом тике будет собирать 90% блоба, на новом тике начинает заново и никогда не синхронизируется. Лучше было бы добить оставшиеся 10% и отстать на один тик. Лучше синхронизироваться через раз, чем никогда.
- Введём понятие frame expiration. Например, мы решили, что отставать больше чем на 3 тика бессмысленно, но до трех - приемлемо. Тогда пусть сервер бродкастит всегда три последних фрейма. Быстрый клиент получает новый фрейм и игнорирует избыточность. медленный получает как может, возможно только каждый третий - лучше чем ничего.

Самле интересное: как организовать избыточность. Carousel (это когда повторяем всю посылку целиком несколько раз) - плохо, т.к. при потерях надо ждать целый оборот карусели. "Лобовой"  FEC (XOR) - плохо, т.к. пакеты часто теряются со специфичнв=ым паттерном (например 10 пакетов подряд), так что простая избыточность типа  "каждый пятый несет parity bit" (a la RAID) - не работает.

Решение: digital fountain. Свойство алгоритма: нарежем блоб на K = 100 пакетов и преобразуем в N = 500 __разных__ пакетов (символов). Клиенту достаточно получить __любые__ (K + e) = 105 пакетов из 500, чтобы восстановить блоб. Сервер просто передает все 500 пакетов, и каждый клиент восстанавливает блоб со своей скоростью, в зависимости от потерь. Важно, что для конкретного клиента есть гарантия восстановления после того, как он набрал нужное количество. Будем верить, что за expiration time (за три тика) клиент наберет хотя бы один юлоб.

- Для RaptorQ требуемая избыточноть около 1%. Т.е. при получении любых 101 пакетов я имею приличную вероятность восстановления данных. При получении 105 - практически гарантия. Это избыточность на стороне клиента.
- На стороне передачи избыточность получается большая (5x в моём примере). Но для сервера это не проблема, т.к. суммарный трафик умеренный.
- Поскольку сервер бродкастит одновременно три последних фрейма, а клиент пытается их получить - может случиться, что клиент наберет последний фрейм раньше, чем предпоследний. ну и прекрасно: предпоследний ему больше не нужен, м 

- multicast, unicast, broadcast - не имеет значения в контексте этого предложения (возможны разные варианты реализации)